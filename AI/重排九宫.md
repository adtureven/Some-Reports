# 重排九宫





## 问题描述

​        给定一个 3x3 的方格，其中包含数字 1 到 8 和一个空格（用 0 表示），目标是通过交换相邻的数字，将方格中的数字重新排列成一个特定的目标状态。每一步可以将空格与相邻的数字交换，这样就能够逐步达到目标状态。



## 算法描述

### 总体概述



以下是给定程序的简要算法描述：

1. **数据结构定义：**
   - 定义了一个结构体 `nineSquare` 用于表示九宫格状态。
   - 使用两个数组 `open` 和 `close` 分别表示开放列表和关闭列表。
   - 使用变量 `otop`、`oinr`、`obot` 表示开放列表的顶部、当前内部指针和底部。
   - 使用变量 `ctop` 表示关闭列表的顶部。

2. **函数定义：**
   - `over()`：检查是否发生溢出。
   - `disp(a[3][3])`：打印九宫格状态。
   - `check(a[3][3])`：检查是否达到目标状态。
   - `find_zero(a[3][3])`：找到空格的位置。
   - `exchange(i, j, a[3][3])`：交换两个位置的值。
   - `bfs(a)`、`dfs(a)`、`astar(a)`：分别为广度优先搜索、深度优先搜索和A*搜索算法。
   - `cmp(a[3][3], b[3][3])`：比较两个九宫格状态是否相同。
   - `cost(a)`：计算九宫格状态的代价函数。
   - `path()`：打印搜索路径。
   - `index(a[], at, b[], bt)`：在A*算法中找到代价最小的节点的索引。

3. **主函数：**
   - 初始化九宫格的初始状态 `a`。
   - 检查是否已经达到目标状态，若是，则输出不需要操作。
   - 选择算法类型（BFS、DFS、A*）。
   - 使用相应的算法进行搜索，并记录搜索路径。
   - 打印搜索路径。

4. **搜索算法：**
   - **BFS（广度优先搜索）：** 使用循环不断扩展状态，直到达到目标状态。
   - **DFS（深度优先搜索）：** 使用递归深度优先搜索，遇到回溯时回退。
   - **A*搜索：** 使用代价函数计算节点代价，选择代价最小的节点进行扩展。

5. **搜索路径显示：**
   - 使用 `path()` 函数回溯并显示搜索路径。

这个程序主要是针对八数码问题进行搜索，其中实现了广度优先搜索、深度优先搜索和A*搜索三种不同的搜索算法。算法的选择由用户在程序运行时输入。



### BFS

- `bfs` 函数用于进行广度优先搜索。
- 通过找到空格的位置，对其相邻的四个方向进行扩展，即左、上、下、右。
- 对每一次扩展，将新的状态存入 `open` 列表尾部，并检查是否溢出。如果溢出，说明队列已满，退出搜索。



### DFS

- `dfs` 函数用于进行深度优先搜索。
- 通过找到空格的位置，对其相邻的四个方向进行扩展，即左、上、下、右。
- 对每一次扩展，将新的状态存入 `open` 列表，并检查是否溢出。如果溢出，说明栈已满，退出搜索。
- 使用 `a.dp` 记录深度，每次扩展后递增或递减，用于控制深度。



### A*

- `astar` 函数用于进行A*搜索。
- 通过找到空格的位置，对其相邻的四个方向进行扩展，即左、上、下、右。
- 对每一次扩展，将新的状态存入 `open` 列表，并检查是否溢出。如果溢出，说明队列已满，退出搜索。
- 使用 `a.dp` 记录深度，每次扩展后递增或递减，用于控制深度。
- 在 A* 中，对每个节点计算代价函数 `cost(a)`，选择代价最小的节点进行扩展。其中 `cost(a)` 包括节点到目标状态的代价和节点深度。通过 `index` 函数找到代价最小的节点。



## 实验结果

### BFS

<img src="C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20231209124835263.png" alt="image-20231209124835263" style="zoom:50%;" />



### DFS

<img src="C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20231209124938967.png" alt="image-20231209124938967" style="zoom:50%;" />

### A*

<img src="C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20231209124954917.png" alt="image-20231209124954917" style="zoom:50%;" />

## 实验结果分析

从以上的结果截图来看，三种算法得到的路径都相同。

尽管路径相同，但是我们可以知道他们检索的路径并不相同。

**BFS算法总共扩展的节点数为26个**

**DFS算法总共扩展的节点数为46个** *有界DFS深度为5*

**A*算法总共扩展的节点数为5个**

### BFS

![image-20231209132908192](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20231209132908192.png)



### DFS

![image-20231209133305877](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20231209133305877.png)



### A*

![image-20231209133937310](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20231209133937310.png)

## 不同算法的性能对比

1.**差异**： 

广度优先搜索是将结点 n 的子结点放入到 OPEN 表的尾部 （类似队列） ；

深度优先搜索是把结点 n 的子结点放入到 OPEN 表的首部（类似栈）；

A* 算法则是将结点 n 的子结点放入到 OPEN 表后，再将 OPEN 表中的结点按照估价函数进行排序（类似优先队列）。

2.**性能**： 

**BFS算法总共扩展的节点数为26个**

**DFS算法总共扩展的节点数为46个** *有界DFS深度为5*

**A*算法总共扩展的节点数为5个**

耗时在如此短的算法中都非常小。

可以看到A*算法的拓展节点是最少的，但是需要花费额外的时间找出代价最小的节点进行拓展；

BFS算法扩展的节点数适中，每次拓展open表头就可，不需要花费额外的时间寻找节点；

而DFS有界的搜索过程和限制的界深度有直接关系，深度为5时拓展的节点是46个，深度为4时拓展就为26个；每次拓展open表头，拓展节点放入表头，也不需要额外时间寻找合适的节点。当然没有界深度限制就有极大可能找不到解。

**总而言之：A*算法的各方面都比较优秀 ，在许多情况下都是一个优秀的选择，它结合了广度优先搜索和启发式函数，具有较好的搜索速度和空间效率。**



## 源代码

```c++
#include <iostream>
#include <cstring>
#include <chrono>

using namespace std;

typedef struct nineSquare{
    int nine[3][3];
    int dp;
    struct nineSquare *n;
}nS;

nS open[1000000];
nS close[1000000];
int otop=1;
int oinr=1;
int obot=0;
int ctop=0;
//check overflow
int over(){
    if(otop==999999) {
        cout<<"overflow"<<endl;
        return 1;
    }
    return 0;
}
//print the result
void disp(int a[3][3]){
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            if(a[i][j]!=0) cout<<a[i][j]<<" ";
            else cout<<"  ";
        }
        cout<<endl;
    }
}
//check the array
int check(int a[3][3]){
    if(a[0][0]!=1||a[0][1]!=2||a[0][2]!=3) return 1;
    if(a[1][0]!=8||a[1][1]!=0||a[1][2]!=4) return 1;
    if(a[2][0]!=7||a[2][1]!=6||a[2][2]!=5) return 1;
    return 0;
}
//find the location of 0
int find_zero(int a[3][3]){
    int lo=0;
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            if(a[i][j]==0) return lo;
            lo++;
        }
    }
    return lo;
}
//swap
void exchange(int i,int j,int a[3][3]){
    int t=a[i/3][i%3];
    a[i/3][i%3]=a[j/3][j%3];
    a[j/3][j%3]=t;
}
//BFS
void bfs(nS a){
    int zero=find_zero(a.nine);
    if((zero%3)!=0){//left ext
        exchange(zero-1,zero,a.nine);
        open[otop++]=a;
        if(over()) return ;
        exchange(zero-1,zero,a.nine);
    }
    if(zero>=3){//up ext
        exchange(zero-3,zero,a.nine);
        open[otop++]=a;
        if(over()) return ;
        exchange(zero-3,zero,a.nine);
    }
    if(zero<=5){//down ext
        exchange(zero+3,zero,a.nine);
        open[otop++]=a;
        if(over()) return ;
        exchange(zero+3,zero,a.nine);
    }
    if((zero+1)%3 != 0){//right ext
        exchange(zero+1,zero,a.nine);
        open[otop++]=a;
        if(over()) return ;
        exchange(zero+1,zero,a.nine);
    }
}
//DFS
void dfs(nS a){
    int zero=find_zero(a.nine);
    if((zero%3)!=0){//left ext
        exchange(zero-1,zero,a.nine);
        a.dp++;
        open[otop++]=a;
        a.dp--;
        if(over()) return ;
        exchange(zero-1,zero,a.nine);
    }
    if(zero>=3){//up ext
        exchange(zero-3,zero,a.nine);
        a.dp++;
        open[otop++]=a;
        a.dp--;
        if(over()) return ;
        exchange(zero-3,zero,a.nine);
    }
    if(zero<=5){//down ext
        exchange(zero+3,zero,a.nine);
        a.dp++;
        open[otop++]=a;
        a.dp--;
        if(over()) return ;
        exchange(zero+3,zero,a.nine);
    }
    if((zero+1)%3 != 0){//right ext
        exchange(zero+1,zero,a.nine);
        a.dp++;
        open[otop++]=a;
        a.dp--;
        if(over()) return ;
        exchange(zero+1,zero,a.nine);
    }
}
//Astar
void astar(nS a){
    int zero=find_zero(a.nine);
    if((zero%3)!=0){//left ext
        exchange(zero-1,zero,a.nine);
        a.dp++;
        open[otop++]=a;
        a.dp--;
        if(over()) return ;
        exchange(zero-1,zero,a.nine);
    }
    if(zero>=3){//up ext
        exchange(zero-3,zero,a.nine);
        a.dp++;
        open[otop++]=a;
        a.dp--;
        if(over()) return ;
        exchange(zero-3,zero,a.nine);
    }
    if(zero<=5){//down ext
        exchange(zero+3,zero,a.nine);
        a.dp++;
        open[otop++]=a;
        a.dp--;
        if(over()) return ;
        exchange(zero+3,zero,a.nine);
    }
    if((zero+1)%3 != 0){//right ext
        exchange(zero+1,zero,a.nine);
        a.dp++;
        open[otop++]=a;
        a.dp--;
        if(over()) return ;
        exchange(zero+1,zero,a.nine);
    }
}
//same
int cmp(int a[3][3],int b[3][3]){
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            if(a[i][j]!=b[i][j]) return 1;
        }
    }
    return 0;
}
//cost
int cost(nS a){
    int num=0;
    if(a.nine[0][0]!=1&&a.nine[0][0]!=0) num++;
    if(a.nine[0][1]!=2&&a.nine[0][1]!=0) num++;
    if(a.nine[0][2]!=3&&a.nine[0][2]!=0) num++;
    if(a.nine[1][0]!=8&&a.nine[1][0]!=0) num++;
    if(a.nine[1][1]!=0) num++;
    if(a.nine[1][2]!=4&&a.nine[1][2]!=0) num++;
    if(a.nine[2][0]!=7&&a.nine[2][0]!=0) num++;
    if(a.nine[2][1]!=6&&a.nine[2][1]!=0) num++;
    if(a.nine[2][2]!=5&&a.nine[2][2]!=0) num++;

    return num+a.dp;
}
//show path
void path(){
    nS *b=&open[obot];
    nS *c[1000];
    int i=0;
    while(1){
        c[i++]=b;
        if(b->n==NULL) break;
        b=b->n;
    }
    for(int j=i-1;j>0;j--){
        disp(c[j]->nine);
        cout<<"  ↓   "<<endl;
    }
    disp(c[0]->nine);
}
//astar find the minist 
int index(nS a[],int at,nS b[],int bt){
    int flag[10000]={0};
    for(int i=0;i<at;i++){
        for(int j=0;j<bt;j++){
            if(cmp(a[i].nine,b[j].nine)==0){
                flag[i]=1;
                break;
            }
        }
    }
    int min=100;
    int index=0;
    for(int i=0;i<at;i++){
        if(flag[i]==0){
            if(cost(a[i])<min){
                min=cost(a[i]);
                index=i;
            }
        }
    }
    return index;
}

int main(){

    nS a;
    a.n=NULL;
    a.dp=0;

    a.nine[0][0]=2;
    a.nine[0][1]=8;
    a.nine[0][2]=3;
    a.nine[1][0]=1;
    a.nine[1][1]=0;
    a.nine[1][2]=4;
    a.nine[2][0]=7;
    a.nine[2][1]=6;
    a.nine[2][2]=5;

    if(check(a.nine)==0){
        cout<<"your input need no operation"<<endl;
        return 0;
    }

    //cout<<cost(a)<<endl;;

    cout<<"select a algorithm: "<<endl;
    char al[3][10]={"bfs","dfs","astar"};
    char p[10];
    cin>>p;
    int i=0;
    for(i=0;i<3;i++){
        if(strcmp(p,al[i])==0) break;
    }


    open[0]=a;
    open[0].dp=0;
    open[0].n=NULL;

    auto start_time = chrono::high_resolution_clock::now();

    if(i==0){//bfs
        while(check(open[obot].nine)==1){
            int flag=0;
            for(int i=0;i<ctop;i++){
                if(cmp(open[obot].nine,close[i].nine)==0){
                    obot++;
                    flag=1;
                    break;
                }      
            }

            if(flag==1) continue;

            close[ctop]=open[obot];
            obot++;      
            bfs(close[ctop]);
            if(over()) return 1;
            for(int i=oinr;i<otop;i++){
                open[i].n=&close[ctop];
            }
            ctop++;
            oinr=otop;
        }
    }
    else if(i==1){//dfs
        while(check(open[obot].nine)==1&&otop!=ctop){
            int flag=0;
            for(int i=0;i<ctop;i++){
                if(cmp(open[obot].nine,close[i].nine)==0){
                    obot--;
                    flag=1;
                    break;
                }      
            }
            if(flag==1) continue;

            if(open[obot].dp==5){
                close[ctop++]=open[obot--];
                flag=1;
            }
            if(flag==1) continue;

            close[ctop]=open[obot];
            obot--;      
            dfs(close[ctop]);
            if(over()) return 1;
            for(int i=oinr;i<otop;i++){
                open[i].n=&close[ctop];
            }
            ctop++;
            oinr=otop;
            obot=otop-1;
        }
    }
    else{//astar
        while(check(open[obot].nine)==1&&otop!=ctop){

            close[ctop]=open[obot];   

            astar(close[ctop]);

            if(over()) return 1;
            for(int i=oinr;i<otop;i++){
                open[i].n=&close[ctop];
            }

            ctop++;
            oinr=otop;

            obot=index(open,otop,close,ctop);

        }
    }
    cout<<ctop<<" extended"<<endl;
    auto end_time = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::milliseconds>(end_time - start_time);
    cout << "Algorithm executed in " << duration.count() << " milliseconds." << endl;
    path();

    return 0;
}
```

