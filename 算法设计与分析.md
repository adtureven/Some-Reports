# 算法设计与分析

## 算法概述



计算机求解问题的一般步骤：
1.理解问题；2.选择数据结构和算法分析策略；**3.设计算法；4.证明正确性；5.分析算法6，设计程序。**

**算法的特点：** 输入输出；确定性；**有限性**；可行性。（程序可以不满足有限性，如操作系统）



时间复杂度：

![image-20230425232806186](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230425232806186.png)

![image-20230425232853037](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230425232853037.png)

![image-20230425232918755](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230425232918755.png)

![image-20230425233004842](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230425233004842.png)





## 递归与分治策略

### 递归

考虑递归求解：1.当问题和子问题有递推关系时；2.具有递推性质的数据结构；3.反向性问题；

根本要素：**抓住问题本身是否可以通过层层拆解到最小粒度来得解。**

递推关系式包含两方面：1.边界条件；2.递归方程。

#### n!函数

```C++
int f(int n){
    if(n==0) return 1; //边界条件f(0)=1;f(1)=1;
    return n*f(n-1);   //递归方程f(n)=n!=n*(n-1)!
}
```

调用f函数时，计算f(n) 先计算f(n-1)，而计算f(n-1)要先计算f(n-2)..

将f(n-1),f(n-2)...依次压入栈中，利用了O(n)的栈空间。时间复杂度为O(n)；

#### Fibonacci数

```c++
int f(int n){
    if(n==0||n==1) return 1;//边界条件f(0)=1;f(1)=1;
    return f(n-1)+f(n-2);   //递归方程
}
```

![image-20230402142740806](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230402142740806.png)



求解f函数由树来表示求解过程，时间复杂度可以大概表示为O(2^n)；空间复杂度即是树的高度(同时创建变量的个数)O(n);



#### LeetCode 70.爬楼梯

这是可以用递归解决的第一类问题，具有递归性质的问题。

**假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。**

**每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？**

首先得写出**递推关系式**；

1.**边界条件**：只要上一级台阶时，方法只有一种，要上两级时可以一级一级上，也可以依次上两级，二就是两种方法。

2.**递归方程**：要上n级台阶，自上而下思考，可以从n-1级台阶向上跳一级，或者从n-2级台阶向上跳两级。

```c++
int jump(int n){
    if(n==1) return 1;           //边界条件
    if(n==2) return 2;           //边界条件
    return jump(n-1)+jump(n-2);  //递归方程
}
```

复杂度和上述的Fibonacci数类似。时间复杂度可以大概表示为O(2^n)；空间复杂度即是树的高度(同时创建变量的个数)O(n);本题也可以优化，在以后讨论。



#### LeetCode 2.两数相加

这是可以用递归解决的第二类问题，有递归性质的数据结构，链表。

**给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。**

**请你将两个数相加，并以相同形式返回一个表示和的链表。**

**你可以假设除了数字 0 之外，这两个数都不会以 0 开头。**

![image-20230402173613556](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230402173613556.png)

先求递归关系式。

1.**边界条件** 当遍历到的链表为空时，直接返回另一个链表；

2.**递归方程** 我们将两个结点的值相加到L1的结点上，在递归L1.next结点将其接在L1后面。

```c++
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    if(!l1) return l2;   //边界条件
    if(!l2) return l1;   //边界条件
    l1->val+=l2->val;
    int carry=0;
    if(l1->val>=10) {l1->val-=10;carry=1;}
    if(carry==1){
        ListNode *h=new ListNode(1);
        l1->next=addTwoNumbers(h,l1->next);
    }
    l1->next=addTwoNumbers(l1->next,l2->next);
    return l1;
}
```

如果结点值相加后大于9，则得新建一结点，将其与以后面结点为头结点的链表相加(即调用此函数)。

最后返回初始的L1的头结点。



#### LeetCode 206.反转链表

本题是递归问题的第三种情形，同时也有具有递归性质的数据结构链表。

**给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。**

![image-20230402173510495](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230402173510495.png)

同样先分析出递推关系式，

1.**边界条件** 当链表只有一个结点时，直接返回此结点。

2.**递归方程** 我们可以假设已经反转了一部分的链表，将未反转的部分链表调用函数反转后接在已反转链表的尾结点上。

```c++
ListNode* reverseList(ListNode* head) {
    if(head==NULL||head->next==NULL) return head;
    ListNode* tt=reverseList(head->next);
    head->next->next=head;
    head->next=NULL;   //调转head和head->next结点方向
    return tt;
}
```

先将head->next->next的指针指回head，就成功创建了反转箭头，然后需要把原指针给置NULL即可。





#### LeetCode 97.交错字符串

给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。

两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：

s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
|n - m| <= 1
交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...
注意：a + b 意味着字符串 a 和 b 连接。

![image-20230408101645538](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230408101645538.png)

```c++
bool isInterleave(string s1, string s2, string s3) {
        int n1=s1.length();
        int n2=s2.length();
        int n3=s3.length();
        if(n1+n2!=n3) return false;
        if(s1==s3||s2==s3) return true;
        if(n1==0) return s2==s3;
        if(n2==0) return s1==s3;
        bool t1=isInterleave(s1.substr(0,n1-1),s2,s3.substr(0,n3-1));
        bool t2=isInterleave(s1,s2.substr(0,n2-1),s3.substr(0,n3-1));
        if(s1[n1-1]==s3[n3-1]&&s1[n1-1]==s2[n2-1]){
            return t1+t2;
        }
        else if(s1[n1-1]==s3[n3-1]){
            return t1;
        }
        else if(s2[n2-1]==s3[n3-1]){
            return t2;
        }
        else return false;
        return true;
    }
```







#### 小结 

先观察分析所求问题是否能用递归来求解，一般属于上述三类问题都可使用递归。

确定使用递归求解后，需要分析出口（就是边界条件，退出递归），然后分析一般式（递推方程）。





### 分治

分治法的基本思想是将一个规模较大的问题分解成几个规模较小的问题，互相独立并且与原问题相同，递归求解并最后合并得到原解。

**一般步骤** 

① 将原问题分解成若干个规模较小的子问题（子问题和原问题的结构一样，只是规模不一样）

② 子问题又不断分解成规模更小的子问题，直到不能再分解（直到可以轻易计算出子问题的解）

③ 利用子问题的解推导出原问题的解



#### 二分搜索

leetcode 704.二分查找

原问题是在一个有序数组中搜索一个数，我们发现这个问题可以进行分解：分成左半边搜索和右半边搜索。其中某一个子问题的解即是原问题的解。

```c++
//假设a数组是非降序数组
int bsort(int a[],int left,int right,int num){
    if(left>right) return -1; //未找到num
    int mid=(left+right)>>1;
    if(a[mid]==num) return mid;
    else if(a[mid]>num)return bsort(a,left,mid-1,num);
    else return bsort(a,mid+1,right,num);
}
```

搜索区间设置为左闭右闭，即[left, right]；当目标值小于中间值时，说明目标值只可能在[left，mid-1]中，故舍去右边；大于中间值时同理。



#### 归并排序

归并排序基于分治思想，在每一层递归上有三个步骤。

- **分解（Divide）**：将n个元素分成个含n/2个元素的子序列。
- **解决（Conquer）**：用合并排序法对两个子序列递归的排序。
- **合并（Combine）**：合并两个已排序的子序列已得到排序结果。

![image-20230402194342257](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230402194342257.png)

将原数组不停的进行二分，分到只有一个为止，在将他们不停得合并成有序的数组，最终得到的即是一个有序数组。

```c++
//合并两段有序数组
void merge(int a[],int left,int mid,int right){
    vector<int> b;
    int i=left,j=mid;
    while(i<mid&&j<=right){
        if(a[i]<=a[j]) {b.push_back(a[i]);i++;}
        else {b.push_back(a[j]);j++}
    }
    while(i<mid){b.push_back(a[i]);i++;}
    while(j<=right) {b.push_back(a[j]);j++}
    for(int k=left;k<=right;k++){
        a[k]=b[k-left];
    }
}
//归并排序主体
void Mergesort(int a[],int left,int right){
    if(left==right) return ;
    int mid=(left+right)>>1;
    Mergesort(a,left,mid);
    Mergesort(a,mid+1,right);
    merge(a,left,mid,right);
}
```

时间复杂度只有$O(nlogn)$ ，并且与原数组混乱程度无关。



#### 快速排序

快速排序是基于分治策略的另一种排序算法。

**分解** 找到数组的基准元素，将原数组分解为基准元素的左边和基准元素的右边；

**递归** 分别对分解后的左边和右边的数组进行快速排序；

**合并** 将分解后的两边数组排序合并到一起；

```c++
//找到基准位置并交换
int part(int a[],int left,int right){
    int p=a[left];
    int i=left,j=right;
    while(i<j){
        while(a[j--]>p){}
        while(a[i++]<p){}
        if(i<j) swap(a[i],a[j]);
    }
    a[left]=a[i];
    a[i]=p;          //交换a[left]和a[i]的值
    return i;
}
//快速排序主体
void QuickSort(int a[],int left,int right){
    if(left==right) return ;
    int p=part(a,left,right);
    QuickSort(a,left,p-1);
    QuickSort(a,p+1,right);
}
```

快排的时间复杂度会根据原数组的混乱程度变换，最坏情况（数组基本有序），分治分成了两个不对称部分：T(n)=T(n-1)+O(n); T(n)=n^2;

最好情况下，每次划分都恰好分成相同两份，T(n)=2*T(n/2)+O(n);

$T(n)=O(nlogn)$;



#### LeetCode 50.Pow(x,n)

本题用到了快速幂算法，本质上也是一种分治算法。

**实现 [pow(*x*, *n*)]，即计算 `x` 的整数 `n` 次幂函数（即，`x^n` ）**

![image-20230402210054230](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230402210054230.png)

n是偶数时，2的n次可以表示为`2^(n/2)*2^(n/2)` ;

n是奇数时，2的n次可以表示为`2^(n/2)*2^(n/2)*2` ;

```c++
//递归函数，分奇偶进行递归；
double quickMul(double x, long long n) {
    if (n == 0) return 1.0;
        double y = quickMul(x, n / 2);
        return N % 2 == 0 ? y * y : y * y * x;
}
//主函数，分指数的正负分别返回；
double myPow(double x, int n) {
    long long N = n;
    return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
}
```

时间复杂度与空间复杂度都为`O(logn)`;



#### LeetCode 53.最大子数组和

**给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。**

**子数组** 是数组中的一个连续部分。

![image-20230402213121190](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230402213121190.png)

采用分治策略解答本题，可以使用对称分解；

**分解** 按中间将数组划分成左右两个部分。

**递归** 通过递归将数组分割至最小单元。

**合并** 将每个子数组分别得到的最大子数组和合并，这里分为三种情况：

​	1.合并后数组的最大子数组和为未合并前的左数组的最大子数组和

​	2.合并后数组的最大子数组和为未合并前的右数组的最大子数组和

​	3.合并后数组的最大子数组和包含了左边部分和右边部分；

第三种情况较为复杂，显然这种情况的最大子数组必然包含左右两边的分割处`a[mid]` ;

```c++
//设计一个函数来求第三种情况的最大子数组和
int findcross(vector<int>&nums,int l,int mid,int r){
    int sum=nums[mid];
    int max=sum;
    for(int i=mid-1;i>=l;i--){  //从mid处向前遍历，找最大
        sum+=nums[i];
        max=max>sum?max:sum;
    }
    sum=nums[mid+1];
    int maqx=sum;
    for(int i=mid+2;i<=r;i++){  //从mid后往后遍历，找最大
        sum+=nums[i];
        maqx=maqx>sum?maqx:sum;
    }
    return max+maqx;            //返回两个最大之和
}
```

我们最终合并后得到最大子数组和必然是这三种情况取最大，由此可以写出主函数。

```c++
int findsum(vector<int>& nums,int l,int r){
    if(l==r) return nums[l];
    int mid=(l+r)>>1;
    int lsum=findsum(nums,l,mid);
    int rsum=findsum(nums,mid+1,r);
    int csum=findcross(nums,l,mid,r);
    return max(lsum,max(rsum,csum));
}
```

最后调用主函数即可`findsum(nums,0,nums.size()-1);` 

**T(n)=2*T(n/2)+O(n)**

时间复杂度为`O(logn)`;



#### 寻找带权中位数

![image-20230403214306244](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230403214306244.png)

本题关键是寻找一个数，使小于x的数权值之和小于等于1/2，大于x的权值之和也小于等于1/2。

**分解** 移动一个基准值，使其左边的数都小于它，右边的数都大于它。

**递归** 将分解好的数组左右权值求和，对大于1/2的部分数组递归分解

**合并** 最后递归得到的出口值即为原问题的解，不需要合并。

```c++
//length为目前递归中数组尾下标+1，num为输入数组，weight为权值，index为递归中数组首位下标
void WeightMedian(int length,vector<int>num,vector<double>weight,int index){
    int p=num[index];
    int i=index,j=length-1;
    while(i<j){
        while(j>i&&num[j]>p){j--;}
        while(i<j&&num[i]<=p){i++;}
        if(i<j) {
            swap(num[i],num[j]);
            swap(weight[i],weight[j]);
        }
    }
    swap(num[index],num[i]);
    swap(weight[index],weight[i]);          //上面对数组做了分解，将基准归位
    double sum1=0,sum2=0;
    for(int k=0;num[k]<num[i];k++){
        sum1+=weight[k];                    //判断目前基准左边权值之和
    }
    for(int k=i+1;k<(int)num.size();k++){
        sum2+=weight[k];                    //判断目前基准右边权值之和
    }
    if(sum1<=0.5&&sum2<=0.5) {cout<<num[i];return;}      //若满足题给条件直接返回
    else if(sum1>0.5) WeightMedian(i,num,weight,index);  //视情况分别对左右递归
    else WeightMedian(length,num,weight,i+1);
}
```

此分治算法计算一半时直接将另一半舍去，故最好的情况下时间复杂度为$O(logn)$ ,而最坏的情况下，每次基准值刚好都为边界，相当于遍历了一边原数组，故时间复杂度为$O(n)$ ;





#### 时间复杂度计算

形如$T(n)=a*T(n/b)+O(n^d)$ 的时间复杂度可以直接利用master定理：

![image-20230402222559913](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230402222559913.png)

#### 小结

分治算法在几乎所有场景下都能使用，但是大部分时候使用分治算法复杂度都不太如意。分治法步骤就分为分解，递归和合并三步，合并一般需要仔细分析。











# 动态规划

**与分治算法类似，动态规划问题也是将原问题分解成若干个子问题进行求解，但是这里的子问题往往是相互关联的。**



动态规划算法将互相关联的子问题的解存储下来，方便为规模更大的子问题简化复杂度，**动态规划算法的基本要素：1.最优子结构性质；2.重叠子问题性质**

解题一般步骤：

1.穷举分析最优解结构；

2.确定边界

3.找规律确定最优子结构

4.写出递归方程（状态转移方程）



### 最长公共子序列

**最长公共子序列（LCS）：**就是A和B的**公共子序列中长度最长的**（包含元素最多的）

公共子序列的长度由c数组存储；

![image-20230407213350944](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230407213350944.png)

利用c数组将子序列拼接上去；

```c++
void LCS(vector<char>&a,vector<char>&b){
    int **c=new int*[a.size()];
    int **d=new int*[a.size()];
    for(int i=0;i<a.size();i++){
        c[i]=new int[b.size()];
        d[i]=new int[b.size()];
    }
    for(int i=0;i<a.size();i++){
        for(int j=0;i<b.size();j++){
            if(i==0||j==0) {c[i][j]=0;d[i][j]=0;}
            else if(a[i]==b[j]){
                c[i][j]=c[i-1][j-1]+1;
                d[i][j]=1;
            }
            else{
                c[i][j]=max(c[i][j-1],c[i-1][j]);
                if(c[i][j]==c[i-1][j]){
                    d[i][j]=2;
                }
                else d[i][j]=3;
            }
        }
    }
}
void print(vector<char> a,int** d,int i,int j){
	if(i==0 || j==0) return ;
	if(d[i][j]==1){
		print(a,d,i-1,j-1);
		cout<<a[i];
	}
	else if(d[i][j]==2])
		print(a,d,i,j-1);
	else print(a,d,i-1,j);
}

```



### LeetCode 97.交错字符串

给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。

两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：

s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
|n - m| <= 1
交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...
注意：a + b 意味着字符串 a 和 b 连接。

![image-20230408101645538](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230408101645538.png)

```c++
bool isInterleave(string s1, string s2, string s3) {
        int n1=s1.length();
        int n2=s2.length();
        int n3=s3.length();
        if(n1+n2!=n3) return false;
        bool f[n1+1][n2+1];
         for(int i=0;i<=n1;i++){
            for(int j=0;j<=n2;j++){
                f[i][j]=false;
            }
        }

        f[0][0]=true;
        for(int i=0;i<=n1;i++){
            for(int j=0;j<=n2;j++){
                if(i>0) {
                    f[i][j]|=(f[i-1][j]&&s1[i-1]==s3[i+j-1]);
                }
                if(j>0){
                    f[i][j]|=(f[i][j-1]&&s2[j-1]==s3[i+j-1]);
                }
            }
        }
        return f[n1][n2];
    }
```



### LeetCode 120.三角形最小路径和

**给定一个三角形 triangle ，找出自顶向下的最小路径和。**

每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

用一个一维滚动数组存储从三角形顶部到其中某个点的最小路径和；

**最后遍历数组输出最小值即可**

```c++
int minimumTotal(vector<vector<int>>& triangle) {
        int *f=new int[triangle.size()];
        f[0]=triangle[0][0];
        for(int i=1;i<triangle.size();i++){
            for(int j=i;j>=0;j--){
                if(j>0&&j<i) f[j]=min(f[j],f[j-1])+triangle[i][j];
                else if(j==0) f[0]=f[0]+triangle[i][0];
                else if(j==i) f[i]=f[i-1]+triangle[i][j];
            }
        }
        int ans=f[0];
        for(int i=1;i<triangle.size();i++){
            ans=min(f[i],ans);
        }
        return ans;
    }
```







### LeetCode 53.最大子数组和

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。



用一个数组存储以每个数为结尾的最大子数组和，再取最大值。

```c++
int maxSubArray(vector<int>& nums) {
    int p=nums.size();
    int dp[p];
    dp[0]=nums[0];
    for(int i=1;i<p;++i){
        dp[i]=max(dp[i-1]+nums[i],nums[i]);
    }
    int max=dp[0];
    for(int i=0;i<p;++i){
        max=max>dp[i]?max:dp[i];
    }
    return max;
}
```







### LeetCode 121.买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

![image-20230409203153554](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230409203153554.png)

```c++
int maxProfit(vector<int>& prices) {
    int p=prices.size();
    if(p==1) return 0;
    int *dp=new int[p-1];
    dp[0]=prices[1]-prices[0];
    int ma=dp[0];
    for(int i=1;i<p-1;i++){
        int t=prices[i+1]-prices[i];
        dp[i]=max(t,dp[i-1]+t);
        if(dp[i]>ma) ma=dp[i];
    }
    return ma>0?ma:0;
}
```











# 贪心算法

**1.贪心选择性质**

**2.重叠子问题性质**







# 回溯法

即DFS（深度优先搜索算法）

如果解空间树中从根结点到叶结点的最长路径的长度为 h(n)，则回溯法所需的计算空间通常为O(h(n))。而显式地存储 整个解空间则需要O(2h(n))或O(h(n)!)内存空间。

当所给的问题是从n个元素的集合S中找出满足某种性质的 子集时，相应的解空间树为子集树（左图）。如0-1背包问 题，通常有2 n个叶结点，结点总个数为2 n+1-1。遍历子集树 的任何算法均需Ω(2n)的计算时间。

当所给的问题是确定n个元素满足某种性质的排列时，相应 的解空间为排列树（右图）。排列树通常有n！个结点。因 此遍历排列树需要Ω(n!)的计算时间。旅行售货员问题的解 空间树就是一棵排列树。



# 分支限界法

即BFS（广度优先搜索算法加剪枝函数）





# NP完全性理论

## P类和NP类

**P类（polynomial）** 在多项式时间内能被一台DTM（deterministic turing machine）所接受的问题。

**NP类（non-deterministic polynomial）** 在多项式时间内能被一台NDTM（non-deterministic turing machine）所接受的问题。



简单来说，P类问题就是能在多项式内能够**求得解**的问题，而NP类问题就是能在多项式时间内**验证解**的问题（即不知道是否能在多项式时间内找到问题的解）。



## 计算复杂度归约

假设有一个问题A，我们希望在多项式内解决该问题，现在有另一个问题B，我们知道如何在多项式时间解决它。



我们假设有一个过程，可以将A的输入转化成B的适当输入。

过程有以下特征：**1.转换需要多项式时间；2.两个输入得到的解相同** 

以上过程称为归约算法。

它提供了一种在多项式内解决A问题的算法：

**1.将问题A的输入转换为B的输入；2.解出问题B；3.将B的解转换为A的解。**

用$O(t(n))$ 时间完成1和3.

![image-20230407195827175](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230407195827175.png)

## NP完全性

多项式时间归约提供了一种形式方法，证明，一个问题在多项式时间因子内至少与另一个问题一样难，即A最多比B难一个多项式因子。

**NPC问题（non-deterministic polynomial complete）** 首先是NP问题，其次所有的NP问题都能归约到它。

如果不满足第一个条件，则是**NP-hard** 。



**Cook定理** :布尔表达式的可满足性问题SAT是NP完全的。

cook定理给出了第一个NPC问题，使得对于任何问题Q，只要Q属于NP问题，并且SAT能归约到Q，则Q就是NPC问题。

一些典型的NPC问题：

**1.SAT（布尔表达式的可满足性问题）**

**2.CLQUE（最大团问题）**

**3.VERTEX-COVER（顶点覆盖问题）**

**4.HAM-CYCLE（哈密顿回路）**

**5.TSP（旅行商问题）**

**6.SUBSET-SUM（子集和问题）**







# 近似算法





# 算法优化策略

## 四边形不等式

优化区间dp问题：

![image-20230414212832828](C:\Users\24448\AppData\Roaming\Typora\typora-user-images\image-20230414212832828.png)





